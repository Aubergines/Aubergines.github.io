---
title: Java并发之Thread.join
tags: Java,并发,join
date: 2019-2-17 13:46:36
categories: 并发
grammar_cjkRuby: true
---
##### 前言：刚刚开始学习多线程的`Thread`的时候就知道了`join`这个方法，一直对它只是懵懂的认知。`Waits for this thread to die`是这个方法的作用。

1. 看一个例子

```java
public class SynchronizedClassClass 
        implements Runnable{

    static SynchronizedClassClass synchronizedObjectCodeBlock1 
            = new SynchronizedClassClass();
    static int i = 0;

    public static void main(String[] args) {
        Thread t1 = new Thread(synchronizedObjectCodeBlock1);
        t1.start();
        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
    }

    @Override
    public void run() {
        method();
    }

    public void method(){
        synchronized (SynchronizedClassClass.class){
            for (int j = 0; j < 100000; j++) {
                i++;
            }
        }
    }
}
```
当调用了`t1.join()`方法之后结果返回的值一定是100000,如果没有调用返回的值就是随机的，这个就可以得出线程调用`join`方法之后，该方法后的方法会等待线程执行完之后再执行后续的代码，对于当前的类就是等t1线程执行完`run`方法中的所有的代码后才会执行输出的动作
2. join的源码

```java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
    public final synchronized void join(long millis, int nanos)
    throws InterruptedException {
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }
        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
            millis++;
        }
        join(millis);
    }
	public final void join() throws InterruptedException {
        join(0);
    }
```
通过查看源码可以知道`join()`和`join(long millis, int nanos)`最终都是调用`join(long millis)`,对于`join(long millis)`来说中间的逻辑就是如果给定的等待时间是0的话，表示主线程永远的等待，直到子线程执行完毕。至于`t1.join()`为什么不是子线程的暂停等待，而是主线程，借用大神的理解是调用的`join()`然后调用了`wait`方法其中`wait`是Object类的方法,把对象t1当成是一个普通的对象,调用`wait`方法是让调用方法的线程挂起,和调用的是哪个对象上的`wait`方法没关系。